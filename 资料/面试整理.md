## 1、拆包分包的原理。--metro bundle

通过metro打包，打基础包和全量包都要通过createModuleIdFactory固定 module 的ID，然后用processModuleFilter过滤掉全量包中基础包的内容模块。

重点文件：metro.config.js和metrosplit.config配置metro。
diff.js: 找出common和business的不同行

## 2、RN的性能优化

一、首屏渲染：1、JS bundle的拆包分包
2、缓存：用于解决资源二次访问时的加载性能，优先加载本地缓存、常用图标图片本地打包

二、UI更新：1、减少和合并多个更新，使用shouldComponentUpdate数据浅比较和immutable.js或者是使用pureComponent
2、如果有动画，使用LayoutAnimation过滤动画和使用Animated尽量减少不必要的动画
3、组件的相应速度。InteractionManager:将一些耗时较长的工作安排到所有互动活动画完成之后再进行。requestAnimationFrame(fn)使用在下一帧就立即执行回调。setNativeProps:直接修改原生视图属性，不用通过setState来重新渲染结构。

三、其他优化：1、长列表的加载：使用FlatList首屏按需加载，上下拉刷新加载。2、组件颗粒化：对于常用的组合式页面，抽象出容器组件，用来固定样式和布局，里面的内容用'{children}'。3、网络请求优化


## 原生优化

### 3、原生列表tableView的优化
1、减少cellForRowAtIndexPath代理中的计算量：提前计算每个cell中需要的基本数据，图片异步加载，懒加载，用CALayer优化cell
2、减少heightForRowAtIndexPath代理中计算量：如果高度固定，则设置rowHeight为固定值，如果高度不固定，则把cell高度计算好然后换成起来。


其他：

- cell的复用，
cell高度计算比较费时，可以缓存高度。
减少视图层级，使用layer绘制元素。
对于图片尽量使用确定大小的图片，减少动态缩放，子线程预解码。多线程下载图片碎片，合并显示。

减少透明view

减少离屏幕渲染

合理使用光栅化

异步渲染（Facebook框架AsyncDisplayKit）

### 启动优化：



### 网络优化：

## 4、block什么情况发生循环引用？如何解决？
在一个对象里面强引用了一个block，在该block里面又强引用了该对象，就出现了对象和该block的循环引用。
解决方法：使用__block或者是__weak。


## 5、NSTimer循环引用？如何解决？
timer作为VC的属性，被VC强引用，创建timer对象时VC作为target被timer强引用，即循环引用。timer内部会强引用target，即使传进来的是weak类型，造成这个问题其实是：runLoop=>timer=>target

解决办法：
1、使用weakSelf ：

```
__weak typeof(self) weakSelf = self;

self.timer = [NSTimer scheduledTimerWithTimeInterval:1 
target:weakSelf selector:@selector(timerAction:) userInfo:nil repeats:true];
```

2、使用weakProxy:
NSProxy本身是一个抽象类，它遵循NSObject协议，提供了消息转发的通用接口。NSProxy通常用来实现消息转发机制和惰性初始化资源。

使用NSProxy，你需要写一个子类继承它，然后需要实现init以及消息转发的相关方法。



3、使用GCD timer
```
@interface ViewController ()
@property (nonatomic, strong) dispatch_source_t timer;
@end

- (void)viewDidLoad {
    [super viewDidLoad];
   dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    dispatch_source_set_timer(_timer, dispatch_time(DISPATCH_TIME_NOW, 0), 0.1*NSEC_PER_SEC, 0);
    dispatch_source_set_event_handler(_timer, ^{
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"执行了");
        });
    });
    //开启计时器
    dispatch_resume(_timer);
}
//结束计时
dispatch_source_cancel(_timer);
```

4、Block:

创建NSTimer的分类NSTimer+UnretainCycle。




## 5、ARC与MRC
### ARC下还会发生内存泄漏么？
1.第三方框架不正当使用。
2.block，delegate，NSTimer循环使用。
3.非oc对象的内存处理。
4.地图类处理。
5.大次数循环内存暴涨。
6、死循环

## 6、Runtime：在项目实践中如何使用Runtime，
Runtime：在项目实践中如何使用Runtime：

1> 发送消息(objc_msgSend)
2> 交换方法(method_exchangeImplementations)
3> 动态创建一个类（比如KVO的底层实现）  
4> 动态添加方法，（performSelector）
5> 给分类添加属性。(其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间) objc_setAssociatedObject与objc_getAssociatedObject
6> 字典转模型（利用runtime,遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。）
6> 可以把消息转发给想要的对象，或者随意交换一个方法的实现。


## 7、消息转发


1、对象在收到无法解读的消息后，首先将调用其所属类的下列方法：(NSObject.h中)


```
//尚未实现的方法是类方法
+ (BOOL)resolveClassMethod:(SEL)sel 
//尚未实现的方法是实例方法
+ (BOOL)resolveInstanceMethod:(SEL)sel
```

方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；

2、这步会进入forwardingTargetForSelector:方法，
- (id)forwardingTargetForSelector:(SEL)aSelector用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；

3、这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector

4、这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。
- (void)forwardInvocation:(NSInvocation *)anInvocation



## 8、GCD和Operation




##  9、iOS 开发中常见的锁，哪些场景

@synchronized是对mutex递归锁的封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。最大的问题就是，效率低，传入对象必须等待之前的锁执行完成之后才能执行，无法达到异步的效果。

常见还有以下几种锁机制：

- NSLock：NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK

- NSCondition:条件锁，通过条件变量pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。

- NSConditionLock: 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。

- NSRecursiveLock: 递归锁, 通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型

- pthread_mutex_t: pthread下的互斥锁，互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。

- dispatch_semaphore_t：信号量。

- OSSpinLock: 自旋锁，定义一个全局变量，用来表示锁的可用情况即可。效率最高，但是容易发生锁的优先级反转，导致锁的不安全。
介绍个人在开发过程中在哪些场景下用到过锁。

使用锁的场景：

如下载解压缩，排序显示，加载多张图片然后在都下载完成后合成一张整图等等。



## 10、HTTP缓存在协议上有哪些？




## 11、SSL的Pinning是用什么校验的，可以做到XS抓包不了么？如何防止抓包？


SSL Pinning是一种防止中间人攻击（MITM）的技术，主要机制是在客户端发起请求–>收到服务器发来的证书进行校验，如果收到的证书不被客户端信任，就直接断开连接不继续请求。

产生原理

是这样的，当我们使用抓包工具抓包时，抓包工具在拦截了服务端返回的内容并重新发给客户端的时候使用证书不是服务器端原来的证书，而是抓包工具自己的，抓包工具原来的证书并不是APP开发者设定的服务端原本的证书，于是就构成了中间人攻击，触发SSL Pinning机制导致链接中断，所以我们无法直接抓到包。

常见的开启了SSL Pinning的APP大致分为两种操作：
1、服务端使用了某个权威证书颁发机构（CA）颁发的证书，并且在APP中校验证书是否正常；
2、服务端使用了CA颁发的证书或者自己给自己颁发证书，并且在APP中校验证书本身是否正常的，需要将证书与APP本体一同下发。有把证书混淆在代码里面藏起来的，也有直接放在资源目录下的。



## 防止抓包：
对于HTTPS API接口，如何防止抓包呢？既然问题出在证书信任问题上，那么解决方法就是在我们的APP中预置证书。在TLS/SSL握手时，用预置在本地的证书中的公钥校验服务器的数字签名，只有签名通过才能成功握手。由于数字签名是使用私钥生成的，而私钥只掌握在我们手上，中间人无法伪造一个有效的签名，因此攻击失败，无法抓包。



## 为什么虚拟 dom 会提高性能?(必考)

答：虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

##：react diff 原理（常考，大厂必考）

答：
把树形结构按照层级分解，只比较同级元素。
给列表结构的每个单元添加唯一的 key 属性，方便比较。
React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

